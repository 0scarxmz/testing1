import Database from "better-sqlite3";
import { drizzle } from "drizzle-orm/better-sqlite3";
import { notes } from "./schema";
import { eq } from "drizzle-orm";
import { app } from "electron";
import path from "path";

let dbInstance: ReturnType<typeof drizzle> | null = null;
let sqliteInstance: Database.Database | null = null;

function getDatabase() {
  if (dbInstance) {
    return dbInstance;
  }

  // Get database path in user data directory (cross-platform)
  const dbPath = app && app.isReady()
    ? path.join(app.getPath('userData'), 'notes.db')
    : path.join(process.cwd(), 'notes.db');

  sqliteInstance = new Database(dbPath);

  // Create table if it doesn't exist
  sqliteInstance.exec(`
    CREATE TABLE IF NOT EXISTS notes (
      id TEXT PRIMARY KEY,
      title TEXT,
      content TEXT,
      tags TEXT,
      created_at INTEGER,
      updated_at INTEGER,
      embedding TEXT,
      screenshot TEXT,
      screenshot_path TEXT,
      cover_image_path TEXT,
      auto_generated_title INTEGER DEFAULT 0,
      auto_generated_tags INTEGER DEFAULT 0
    )
  `);

  // Migrate existing databases - add new columns if they don't exist
  try {
    sqliteInstance.exec(`
      ALTER TABLE notes ADD COLUMN screenshot TEXT;
    `);
  } catch (e) {
    // Column already exists, ignore
  }

  try {
    sqliteInstance.exec(`
      ALTER TABLE notes ADD COLUMN screenshot_path TEXT;
    `);
  } catch (e) {
    // Column already exists, ignore
  }

  try {
    sqliteInstance.exec(`
      ALTER TABLE notes ADD COLUMN cover_image_path TEXT;
    `);
  } catch (e) {
    // Column already exists, ignore
  }

  try {
    sqliteInstance.exec(`
      ALTER TABLE notes ADD COLUMN auto_generated_title INTEGER DEFAULT 0;
    `);
  } catch (e) {
    // Column already exists, ignore
  }

  try {
    sqliteInstance.exec(`
      ALTER TABLE notes ADD COLUMN auto_generated_tags INTEGER DEFAULT 0;
    `);
  } catch (e) {
    // Column already exists, ignore
  }

  try {
    sqliteInstance.exec(`
      ALTER TABLE notes ADD COLUMN is_favorite INTEGER DEFAULT 0;
    `);
  } catch (e) {
    // Column already exists, ignore
  }

  try {
    sqliteInstance.exec(`
      ALTER TABLE notes ADD COLUMN status TEXT DEFAULT 'todo';
    `);
  } catch (e) {
    // Column already exists, ignore
  }

  try {
    sqliteInstance.exec(`
      ALTER TABLE notes ADD COLUMN priority TEXT DEFAULT 'medium';
    `);
  } catch (e) {
    // Column already exists, ignore
  }

  dbInstance = drizzle(sqliteInstance, { schema: { notes } });
  return dbInstance;
}

// CRUD functions
export async function getAllNotes() {
  const db = getDatabase();
  // Use explicit field selection to ensure coverImagePath is properly mapped
  const results = await db.select({
    id: notes.id,
    title: notes.title,
    content: notes.content,
    tags: notes.tags,
    createdAt: notes.createdAt,
    updatedAt: notes.updatedAt,
    embedding: notes.embedding,
    screenshot: notes.screenshot,
    screenshotPath: notes.screenshotPath,
    coverImagePath: notes.coverImagePath,
    autoGeneratedTitle: notes.autoGeneratedTitle,

    autoGeneratedTags: notes.autoGeneratedTags,
    isFavorite: notes.isFavorite,
    status: notes.status,
    priority: notes.priority,
  }).from(notes).all();

  // Debug: Check if coverImagePath is being retrieved
  if (results.length > 0) {
    const firstNote = results[0];
    console.log('[db] getAllNotes - First note coverImagePath:', firstNote?.coverImagePath);
    console.log('[db] getAllNotes - First note keys:', Object.keys(firstNote || {}));
  }

  return results;
}

export async function getNote(id: string) {
  const db = getDatabase();
  // Use explicit field selection to ensure coverImagePath is properly mapped
  const result = await db.select({
    id: notes.id,
    title: notes.title,
    content: notes.content,
    tags: notes.tags,
    createdAt: notes.createdAt,
    updatedAt: notes.updatedAt,
    embedding: notes.embedding,
    screenshot: notes.screenshot,
    screenshotPath: notes.screenshotPath,
    coverImagePath: notes.coverImagePath,
    autoGeneratedTitle: notes.autoGeneratedTitle,

    autoGeneratedTags: notes.autoGeneratedTags,
    isFavorite: notes.isFavorite,
    status: notes.status,
    priority: notes.priority,
  }).from(notes).where(eq(notes.id, id)).limit(1);

  const note = result[0] || undefined;

  // Debug: Check if coverImagePath is being retrieved
  if (note) {
    console.log('[db] getNote - coverImagePath value:', note.coverImagePath);
    console.log('[db] getNote - coverImagePath type:', typeof note.coverImagePath);
  }

  return note;
}

export async function createNote(data: {
  id: string;
  title: string;
  content: string;
  tags: string; // JSON string
  createdAt: number;
  updatedAt: number;
  embedding: string | null | number[]; // JSON string, null, or array (will be stringified)
  screenshot?: string | null;
  screenshotPath?: string | null;
  coverImagePath?: string | null;
  autoGeneratedTitle?: number; // 0 or 1
  autoGeneratedTags?: number; // 0 or 1
  isFavorite?: number; // 0 or 1
  status?: string; // 'todo', 'in-progress', 'done'
  priority?: string; // 'low', 'medium', 'high'
}) {
  const db = getDatabase();

  // Handle embedding: stringify arrays, keep strings as-is, default to null (not empty array)
  let embedding: string | null;
  if (data.embedding === null || data.embedding === undefined) {
    embedding = null; // Store null, not empty array string
  } else if (Array.isArray(data.embedding)) {
    // Validate array before stringifying
    if (data.embedding.length === 0) {
      console.warn('Warning: Empty embedding array provided for note', data.id);
      embedding = null;
    } else if (!data.embedding.every(n => typeof n === 'number')) {
      console.error('Error: Invalid embedding array - contains non-numbers for note', data.id);
      embedding = null;
    } else {
      embedding = JSON.stringify(data.embedding);
    }
  } else if (typeof data.embedding === 'string') {
    // Already a string, validate it's valid JSON
    try {
      const parsed = JSON.parse(data.embedding);
      if (!Array.isArray(parsed) || parsed.length === 0) {
        console.warn('Warning: Embedding string contains empty or invalid array for note', data.id);
        embedding = null;
      } else {
        embedding = data.embedding; // Keep as-is
      }
    } catch (e) {
      console.error('Error: Invalid embedding JSON string for note', data.id, e);
      embedding = null;
    }
  } else {
    console.error('Error: Invalid embedding type for note', data.id, typeof data.embedding);
    embedding = null;
  }

  // Drizzle maps createdAt to created_at automatically based on schema
  return db.insert(notes).values({
    id: data.id,
    title: data.title,
    content: data.content,
    tags: data.tags,
    createdAt: data.createdAt,
    updatedAt: data.updatedAt,
    embedding: embedding,
    screenshot: data.screenshot || null,
    screenshotPath: data.screenshotPath || null,
    coverImagePath: data.coverImagePath || null,
    autoGeneratedTitle: data.autoGeneratedTitle ?? 0,
    autoGeneratedTags: data.autoGeneratedTags ?? 0,
    isFavorite: data.isFavorite ?? 0,
    status: data.status ?? 'todo',
    priority: data.priority ?? 'medium',
  }).run();
}

export async function updateNote(id: string, data: {
  title?: string;
  content?: string;
  tags?: string;
  updatedAt?: number;
  embedding?: string | null | number[]; // Can be array (will be stringified) or string or null
  screenshot?: string | null;
  screenshotPath?: string | null;
  coverImagePath?: string | null;
  autoGeneratedTitle?: number; // 0 or 1
  autoGeneratedTags?: number; // 0 or 1
  isFavorite?: number; // 0 or 1
  status?: string; // 'todo', 'in-progress', 'done'
  priority?: string; // 'low', 'medium', 'high'
}) {
  const db = getDatabase();

  // Handle embedding: stringify arrays, validate strings, handle null
  const updateData: any = { ...data };

  // Explicitly handle coverImagePath - ensure null is set if undefined
  if (data.coverImagePath !== undefined) {
    updateData.coverImagePath = data.coverImagePath || null;
  }

  if (data.embedding !== undefined) {
    if (data.embedding === null) {
      updateData.embedding = null;
    } else if (Array.isArray(data.embedding)) {
      // Validate array before stringifying
      if (data.embedding.length === 0) {
        console.warn('Warning: Empty embedding array provided for update, note', id);
        updateData.embedding = null;
      } else if (!data.embedding.every(n => typeof n === 'number')) {
        console.error('Error: Invalid embedding array - contains non-numbers for note', id);
        updateData.embedding = null;
      } else {
        updateData.embedding = JSON.stringify(data.embedding);
      }
    } else if (typeof data.embedding === 'string') {
      // Validate it's valid JSON
      try {
        const parsed = JSON.parse(data.embedding);
        if (!Array.isArray(parsed) || parsed.length === 0) {
          console.warn('Warning: Embedding string contains empty or invalid array for note', id);
          updateData.embedding = null;
        } else {
          updateData.embedding = data.embedding; // Keep as-is
        }
      } catch (e) {
        console.error('Error: Invalid embedding JSON string for note', id, e);
        updateData.embedding = null;
      }
    } else {
      console.error('Error: Invalid embedding type for note', id, typeof data.embedding);
      updateData.embedding = null;
    }
  }

  const result = db.update(notes).set(updateData).where(eq(notes.id, id)).run();

  return result;

  return result;
}

export async function deleteNote(id: string) {
  const db = getDatabase();
  return db.delete(notes).where(eq(notes.id, id)).run();
}

export async function getNotesByTag(tag: string) {
  const db = getDatabase();
  const allNotes = await db.select().from(notes).all();
  return allNotes.filter(note => {
    if (!note.tags) return false;
    const tags = JSON.parse(note.tags);
    return Array.isArray(tags) && tags.includes(tag);
  });
}

export async function searchNotesByText(query: string) {
  const db = getDatabase();
  const allNotes = await db.select().from(notes).all();
  const lowerQuery = query.toLowerCase();
  return allNotes.filter(note => {
    const title = (note.title || '').toLowerCase();
    const content = (note.content || '').toLowerCase();
    let tags: string[] = [];
    if (note.tags) {
      try {
        tags = JSON.parse(note.tags);
      } catch (e) {
        tags = [];
      }
    }
    const tagMatch = tags.some(tag => tag.toLowerCase().includes(lowerQuery));
    return title.includes(lowerQuery) || content.includes(lowerQuery) || tagMatch;
  });
}

export async function getAllTags() {
  const db = getDatabase();
  const allNotes = await db.select().from(notes).all();
  const tagSet = new Set<string>();
  allNotes.forEach(note => {
    if (note.tags) {
      try {
        const tags = JSON.parse(note.tags);
        if (Array.isArray(tags)) {
          tags.forEach(tag => tagSet.add(tag));
        }
      } catch (e) {
        // Ignore invalid JSON
      }
    }
  });
  return Array.from(tagSet).sort();
}

