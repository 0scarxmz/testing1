import type { Note, Relationship, NoteSearchResult } from '@/types/note';
import { generateUUID } from './utils';
import { cosineSimilarity } from './embeddings';

// Type guard to check if desktopAPI is available
function isElectron(): boolean {
  return typeof window !== 'undefined' && typeof (window as any).desktopAPI !== 'undefined';
}

// Convert SQLite note format to Note interface
function sqliteToNote(sqliteNote: any): Note {
  // Defensively parse tags - always ensure we return an array
  let tags: string[] = [];
  if (sqliteNote.tags) {
    try {
      const parsed = JSON.parse(sqliteNote.tags);
      tags = Array.isArray(parsed) ? parsed : [];
    } catch (e) {
      console.warn('Failed to parse tags from SQLite, using empty array:', e);
      tags = [];
    }
  }

  // Defensively parse embedding
  // Handle three cases: already an array (from semanticSearch), JSON string (from regular queries), or null/undefined
  let embedding: number[] | null = null;
  if (sqliteNote.embedding !== null && sqliteNote.embedding !== undefined) {
    try {
      // Case 1: Already an array (from semanticSearch results)
      if (Array.isArray(sqliteNote.embedding)) {
        embedding = sqliteNote.embedding;
      }
      // Case 2: JSON string (from regular getAllNotes, getNote, etc.)
      else if (typeof sqliteNote.embedding === 'string') {
        const parsed = JSON.parse(sqliteNote.embedding);
        embedding = Array.isArray(parsed) ? parsed : null;
      }
      // Case 3: Invalid type
      else {
        console.warn('Invalid embedding type in sqliteToNote:', typeof sqliteNote.embedding);
        embedding = null;
      }
    } catch (e) {
      console.warn('Failed to parse embedding from SQLite:', e);
      embedding = null;
    }
  }

  return {
    id: sqliteNote.id,
    title: sqliteNote.title || '',
    content: sqliteNote.content || '',
    parentId: sqliteNote.parentId || sqliteNote.parent_id || null,
    tags,
    createdAt: sqliteNote.createdAt ?? sqliteNote.created_at ?? Date.now(),
    updatedAt: sqliteNote.updatedAt ?? sqliteNote.updated_at ?? Date.now(),
    embedding,
    screenshot: sqliteNote.screenshot || undefined,
    screenshotPath: sqliteNote.screenshotPath || sqliteNote.screenshot_path || undefined,
    coverImagePath: sqliteNote.coverImagePath || sqliteNote.cover_image_path || undefined,
    iconPath: sqliteNote.iconPath || sqliteNote.icon_path || undefined,
    iconEmoji: sqliteNote.iconEmoji || sqliteNote.icon_emoji || undefined,
    autoGeneratedTitle: sqliteNote.autoGeneratedTitle === 1 || sqliteNote.auto_generated_title === 1,
    autoGeneratedTags: sqliteNote.autoGeneratedTags === 1 || sqliteNote.auto_generated_tags === 1,
    isFavorite: sqliteNote.isFavorite === 1 || sqliteNote.is_favorite === 1,
    status: sqliteNote.status || 'todo',
    priority: sqliteNote.priority || 'medium',
  };
}

// Convert Note interface to SQLite format
function noteToSqlite(note: Partial<Note>): any {
  // Ensure tags are always an array before stringifying
  const tagsArray = Array.isArray(note.tags) ? note.tags : [];

  // Handle embedding: validate and stringify if it's a valid array
  let embedding: string | null = null;
  if (note.embedding !== null && note.embedding !== undefined) {
    if (Array.isArray(note.embedding)) {
      // Validate embedding array
      if (note.embedding.length === 0) {
        console.warn('Warning: Empty embedding array in noteToSqlite for note', note.id);
        embedding = null;
      } else if (!note.embedding.every(n => typeof n === 'number')) {
        console.error('Error: Invalid embedding array - contains non-numbers in noteToSqlite for note', note.id);
        embedding = null;
      } else {
        embedding = JSON.stringify(note.embedding);
      }
    } else {
      console.error('Error: Embedding is not an array in noteToSqlite for note', note.id, typeof note.embedding);
      embedding = null;
    }
  }

  return {
    id: note.id,
    title: note.title || '',
    content: note.content || '',
    parentId: note.parentId || null,
    tags: JSON.stringify(tagsArray),
    createdAt: note.createdAt,
    updatedAt: note.updatedAt,
    embedding: embedding,
    screenshot: note.screenshot || null,
    screenshotPath: note.screenshotPath || null,
    coverImagePath: note.coverImagePath || null,
    iconPath: note.iconPath || null,
    iconEmoji: note.iconEmoji || null,
    autoGeneratedTitle: note.autoGeneratedTitle ? 1 : 0,
    autoGeneratedTags: note.autoGeneratedTags ? 1 : 0,
    isFavorite: note.isFavorite ? 1 : 0,
    status: note.status || 'todo',
    priority: note.priority || 'medium',
  };
}

// Async processing function - generates title, tags, and embedding in background
async function processNoteAsync(noteId: string, content: string) {
  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    console.error('[storage-sqlite] desktopAPI not available for async processing');
    return;
  }

  try {

    // Capture screenshot in background (don't block)
    if (desktopAPI.captureScreenshot) {
      desktopAPI.captureScreenshot(noteId).then(screenshotPath => {
        if (screenshotPath) {
          desktopAPI.updateNote(noteId, {
            screenshotPath: screenshotPath,
            updatedAt: Date.now(),
          }).catch(err => {
            console.error('[storage-sqlite] Failed to update note with screenshot path:', err);
          });
        } else {
          console.warn('[storage-sqlite] Screenshot capture failed for note', noteId);
        }
      }).catch(err => {
        console.error('[storage-sqlite] Screenshot capture error:', err);
      });
    }

    // Generate title, tags, and embedding in parallel
    const [title, tags, embedding] = await Promise.all([
      desktopAPI.generateNoteTitle(content).catch(err => {
        console.error('[storage-sqlite] Failed to generate title:', err);
        return 'untitled';
      }),
      desktopAPI.generateNoteTags(content).catch(err => {
        console.error('[storage-sqlite] Failed to generate tags:', err);
        return [];
      }),
      desktopAPI.generateEmbedding(content).catch(err => {
        console.error('[storage-sqlite] Failed to generate embedding:', err);
        return null;
      }),
    ]);


    // Update note with generated fields
    const tagsJson = JSON.stringify(tags);
    const embeddingJson = embedding ? JSON.stringify(embedding) : null;

    await desktopAPI.updateNote(noteId, {
      title,
      tags: tagsJson,
      embedding: embeddingJson,
      autoGeneratedTitle: 1,
      autoGeneratedTags: 1,
      updatedAt: Date.now(),
    });

  } catch (error) {
    console.error('[storage-sqlite] Error in async processing for note', noteId, ':', error);
  }
}

export async function createNote(note: Omit<Note, 'id' | 'createdAt' | 'updatedAt'>): Promise<Note> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    throw new Error('desktopAPI is not available');
  }
  const id = generateUUID();
  const now = Date.now();

  // Create note with content only - title and tags will be generated async
  const initialNote = {
    autoGeneratedTitle: false,
    autoGeneratedTags: false,
    ...note,
  };

  const sqliteNote = noteToSqlite({
    ...initialNote,
    id,
    createdAt: now,
    updatedAt: now,
  });

  // Save note immediately with default values
  await desktopAPI.createNote(sqliteNote);

  // Trigger async processing in background (don't await)
  if (note.content && note.content.trim().length > 0) {
    processNoteAsync(id, note.content).catch(err => {
      console.error('[storage-sqlite] Failed to start async processing:', err);
    });
  }

  return {
    ...initialNote,
    id,
    createdAt: now,
    updatedAt: now,
  };
}

export async function getNote(id: string): Promise<Note | undefined> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    throw new Error('desktopAPI is not available');
  }
  const sqliteNote = await desktopAPI.getNote(id);

  if (!sqliteNote) {
    return undefined;
  }

  // Debug: Log what we receive from IPC
  console.log('[storage-sqlite] getNote - Received from IPC, coverImagePath:', sqliteNote.coverImagePath);
  console.log('[storage-sqlite] getNote - Received from IPC, cover_image_path:', (sqliteNote as any).cover_image_path);

  const converted = sqliteToNote(sqliteNote);
  console.log('[storage-sqlite] getNote - After conversion, coverImagePath:', converted.coverImagePath);

  return converted;
}

export async function getAllNotes(): Promise<Note[]> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    throw new Error('desktopAPI is not available');
  }
  const sqliteNotes = await desktopAPI.getNotes();

  // Debug: Check first note
  if (sqliteNotes.length > 0) {
    const first = sqliteNotes[0];
    console.log('[storage-sqlite] getAllNotes - First note coverImagePath:', first.coverImagePath);
    console.log('[storage-sqlite] getAllNotes - First note cover_image_path:', (first as any).cover_image_path);
  }

  return sqliteNotes.map(sqliteToNote);
}

export async function updateNote(id: string, updates: Partial<Omit<Note, 'id' | 'createdAt'>>): Promise<Note> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    throw new Error('desktopAPI is not available');
  }

  // Get existing note first
  const existing = await getNote(id);
  if (!existing) {
    console.warn(`[storage-sqlite] Note with id ${id} not found, skipping update`);
    // Return a minimal note object to prevent crashes
    return { id, ...updates, updatedAt: Date.now() } as Note;
  }

  const updated: Note = {
    ...existing,
    ...updates,
    updatedAt: Date.now(),
  };

  const sqliteNote = noteToSqlite(updated);

  await desktopAPI.updateNote(id, {
    title: sqliteNote.title,
    content: sqliteNote.content,
    parentId: sqliteNote.parentId,
    tags: sqliteNote.tags,
    updatedAt: sqliteNote.updatedAt,
    embedding: sqliteNote.embedding,
    screenshot: sqliteNote.screenshot,
    screenshotPath: sqliteNote.screenshotPath,
    coverImagePath: sqliteNote.coverImagePath,
    iconPath: sqliteNote.iconPath,
    iconEmoji: sqliteNote.iconEmoji,
    autoGeneratedTitle: sqliteNote.autoGeneratedTitle,
    autoGeneratedTags: sqliteNote.autoGeneratedTags,
    isFavorite: sqliteNote.isFavorite,
    status: sqliteNote.status,
    priority: sqliteNote.priority,
  });

  return updated;
}

export async function deleteNote(id: string): Promise<void> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    throw new Error('desktopAPI is not available');
  }
  await desktopAPI.deleteNote(id);
}

export async function getNotesByTag(tag: string): Promise<Note[]> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    throw new Error('desktopAPI is not available');
  }
  const sqliteNotes = await desktopAPI.getNotesByTag(tag);

  return sqliteNotes.map(sqliteToNote);
}

export async function searchNotesByText(query: string): Promise<Note[]> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    throw new Error('desktopAPI is not available');
  }
  const sqliteNotes = await desktopAPI.searchNotesByText(query);

  return sqliteNotes.map(sqliteToNote);
}

export async function getAllTags(): Promise<string[]> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    throw new Error('desktopAPI is not available');
  }
  return await desktopAPI.getAllTags();
}

// Relationship operations (placeholder for now)
export async function createRelationship(relationship: Omit<Relationship, 'id' | 'createdAt'>): Promise<Relationship> {
  // TODO: Implement when relationships table is added
  throw new Error('Relationships not yet implemented in SQLite');
}

export async function getNoteRelationships(noteId: string): Promise<Relationship[]> {
  // TODO: Implement when relationships table is added
  return [];
}

/**
 * Semantic search using vector embeddings and cosine similarity
 */
export async function searchNotesSemantic(query: string): Promise<NoteSearchResult[]> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  if (!query || query.trim().length === 0) {
    return [];
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    console.error('[storage-sqlite] ERROR: desktopAPI is not available!');
    throw new Error('desktopAPI is not available. Make sure electron/preload.js is loading correctly.');
  }

  if (typeof desktopAPI.generateEmbedding !== 'function') {
    throw new Error('desktopAPI.generateEmbedding is not a function. Check electron/preload.js');
  }

  if (typeof desktopAPI.semanticSearch !== 'function') {
    throw new Error('desktopAPI.semanticSearch is not a function. Check electron/preload.js');
  }

  try {
    // Generate embedding for query using desktopAPI
    const queryEmbedding = await desktopAPI.generateEmbedding(query);

    // Perform semantic search using desktopAPI
    const rankedResults = await desktopAPI.semanticSearch(queryEmbedding);

    if (rankedResults.length === 0) {
      return [];
    }

    // Convert SQLite results to Note interface
    // rankedResults are in format: { id, title, content, tags (string), embedding (array), score, ... }
    const results: NoteSearchResult[] = rankedResults.map((result: any) => {
      return {
        note: sqliteToNote(result),
        score: result.score || 0,
      };
    });

    return results;
  } catch (error) {
    console.error('[Frontend] Semantic search failed:', error);
    console.error('[Frontend] Error details:', error instanceof Error ? error.message : String(error));
    // If embedding generation fails (e.g., no API key), return empty results
    return [];
  }
}

/**
 * Get related notes based on embedding similarity
 */
export async function getRelatedNotes(noteId: string, limit: number = 3): Promise<NoteSearchResult[]> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  try {
    const currentNote = await getNote(noteId);

    if (!currentNote || !currentNote.embedding) {
      return [];
    }

    // Ensure current note embedding is a valid array
    if (!Array.isArray(currentNote.embedding) || currentNote.embedding.length === 0) {
      return [];
    }

    const currentEmbeddingLength = currentNote.embedding.length;

    const allNotes = await getAllNotes();
    const otherNotes = allNotes.filter(
      note => {
        // Filter out current note and notes without embeddings
        if (note.id === noteId || !note.embedding) {
          return false;
        }

        // Ensure embedding is a valid array with matching length
        if (!Array.isArray(note.embedding) || note.embedding.length !== currentEmbeddingLength) {
          return false;
        }

        return true;
      }
    );

    if (otherNotes.length === 0) {
      return [];
    }

    const results: NoteSearchResult[] = otherNotes
      .map(note => {
        try {
          const similarity = cosineSimilarity(currentNote.embedding!, note.embedding!);
          return {
            note,
            score: similarity,
          };
        } catch (error) {
          // Skip notes with incompatible embeddings
          console.warn(`Skipping note ${note.id} due to embedding mismatch:`, error);
          return null;
        }
      })
      .filter((result): result is NoteSearchResult => result !== null);

    results.sort((a, b) => b.score - a.score);
    return results.slice(0, limit);
  } catch (error) {
    console.error('Failed to get related notes:', error);
    return [];
  }
}

/**
 * Get child notes for a given parent note
 */
export async function getChildNotes(parentId: string): Promise<Note[]> {
  if (!isElectron()) {
    throw new Error('SQLite storage only available in Electron');
  }

  const desktopAPI = window.desktopAPI;
  if (!desktopAPI) {
    throw new Error('desktopAPI is not available');
  }

  const sqliteNotes = await desktopAPI.getChildNotes(parentId);
  return sqliteNotes.map(sqliteToNote);
}
